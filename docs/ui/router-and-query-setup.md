# TanStack Router and Query Setup

This document provides a comprehensive guide to how TanStack Router and TanStack Query are configured and used in this project. It serves as both a reference for developers working on this codebase and a guide for setting up these technologies in similar projects.

## Table of Contents

- [Overview](#overview)
- [TanStack Router Setup](#tanstack-router-setup)
  - [Installation and Configuration](#installation-and-configuration)
  - [Router Initialization](#router-initialization)
  - [Router Context](#router-context)
  - [File-Based Routing](#file-based-routing)
  - [Route Guards and Authentication](#route-guards-and-authentication)
  - [Search Parameter Validation](#search-parameter-validation)
  - [TypeScript Integration](#typescript-integration)
- [TanStack Query Setup](#tanstack-query-setup)
  - [Query Client Configuration](#query-client-configuration)
  - [Query Keys Pattern](#query-keys-pattern)
  - [Custom Hooks Pattern](#custom-hooks-pattern)
  - [Mutations and Cache Invalidation](#mutations-and-cache-invalidation)
  - [Router Integration](#router-integration)
- [Development Tools](#development-tools)
- [Best Practices](#best-practices)

## Overview

This project uses:

- **TanStack Router** (`@tanstack/react-router`) for type-safe, file-based routing
- **TanStack Query** (`@tanstack/react-query`) for server state management and data fetching

Both libraries are integrated to work seamlessly together, with router context being used for authentication state and query hooks being used throughout the application for data fetching and mutations.

## TanStack Router Setup

### Installation and Configuration

**Dependencies:**

```json
{
  "@tanstack/react-router": "^1.127.3",
  "@tanstack/react-router-devtools": "^1.127.3"
}
```

**Dev Dependencies:**

```json
{
  "@tanstack/router-plugin": "^1.127.5"
}
```

**Vite Configuration** (`vite.config.ts`):

```typescript
import {tanstackRouter} from '@tanstack/router-plugin/vite';

export default defineConfig({
  plugins: [
    tanstackRouter({
      target: 'react',
      autoCodeSplitting: true,
    }),
    // ... other plugins
  ],
});
```

The `@tanstack/router-plugin` automatically:

- Generates the route tree from file structure
- Enables code splitting for routes
- Provides type-safe route definitions

### Router Initialization

The router is created in `src/router.tsx`:

```typescript
import {createRouter} from '@tanstack/react-router';
import {routeTree} from './routeTree.gen';
import {DefaultErrorComponent} from '@/components/error-boundary';

export const router = createRouter({
  routeTree,
  context: {isAuthenticated: false},
  defaultErrorComponent: DefaultErrorComponent,
});
```

Key points:

- `routeTree` is auto-generated by the Vite plugin from the file structure
- Initial context provides default values (will be overridden at runtime)
- `defaultErrorComponent` handles errors across all routes

### Router Context

The router uses a typed context to share authentication state throughout the application.

**Context Interface** (`src/routes/__root.tsx`):

```typescript
interface RouterContext {
  isAuthenticated: boolean;
}
```

**Root Route Definition:**

```typescript
import {createRootRouteWithContext, Outlet} from '@tanstack/react-router';
import {TanStackRouterDevtools} from '@tanstack/react-router-devtools';

export const Route = createRootRouteWithContext<RouterContext>()({
  component: () => (
    <section className="bg-primary-foreground w-full min-h-screen">
      <Outlet />
      <TanStackRouterDevtools position="bottom-left" />
    </section>
  ),
});
```

**Context Injection** (`src/app.tsx`):

```typescript
<RouterProvider
  router={router}
  context={{isAuthenticated: Boolean(data && !isError)}}
/>
```

The context is dynamically provided based on authentication state, which is determined by a query hook (e.g., `useGetMe()`).

### File-Based Routing

Routes are defined using file-based routing. Each route file exports a `Route` object created with `createFileRoute`.

**Route File Structure:**

```
src/routes/
  ├── __root.tsx              # Root route
  ├── login.tsx               # /login route
  └── __pathlessLayout/       # Layout route (no URL segment)
      ├── route.tsx           # Layout component with auth guard
      └── main.tsx            # /main route (protected)
```

**Example Route** (`src/routes/login.tsx`):

```typescript
import {createFileRoute} from '@tanstack/react-router';

export const Route = createFileRoute('/login')({
  component: () => (
    <div className="flex items-center justify-center h-screen">
      <h1>Login Page</h1>
    </div>
  ),
});
```

**Pathless Layout Route** (`src/routes/__pathlessLayout/route.tsx`):

```typescript
import {createFileRoute, Outlet, redirect} from '@tanstack/react-router';

export const Route = createFileRoute('/__pathlessLayout')({
  component: RouteComponent,
  beforeLoad: ({context}) => {
    if (!context.isAuthenticated) {
      throw redirect({to: '/login'});
    }
  },
});

function RouteComponent() {
  return (
    <div className="min-h-screen">
      <Outlet />
    </div>
  );
}
```

**Main Route** (`src/routes/__pathlessLayout/main.tsx`):

```typescript
import {createFileRoute} from '@tanstack/react-router';

export const Route = createFileRoute('/__pathlessLayout/main')({
  component: () => (
    <div>
      <h1>Main Page</h1>
      <p>This is a protected route inside the pathless layout.</p>
    </div>
  ),
});
```

Pathless routes (prefixed with `__`) don't add a URL segment but provide layout and shared logic for child routes. All routes under `__pathlessLayout` are automatically protected by the authentication guard.

### Route Guards and Authentication

Routes can use `beforeLoad` to implement authentication guards and redirects.

**Example: Layout with Guard** (`src/routes/__pathlessLayout/route.tsx`):

```typescript
import {createFileRoute, Outlet, redirect} from '@tanstack/react-router';

export const Route = createFileRoute('/__pathlessLayout')({
  component: RouteComponent,
  beforeLoad: ({context}) => {
    if (!context.isAuthenticated) {
      throw redirect({to: '/login'});
    }
  },
});

function RouteComponent() {
  return (
    <div className="min-h-screen">
      <Outlet />
    </div>
  );
}
```

All routes under `__pathlessLayout` are automatically protected by this guard. When an unauthenticated user tries to access any route in this layout, they will be redirected to `/login`.

### Search Parameter Validation

Routes can validate and type-check search parameters (query strings) using Zod schemas.

**Example** (`src/routes/__pathlessLayout/main.tsx`):

```typescript
import {createFileRoute, useSearch} from '@tanstack/react-router';
import z from 'zod';

const searchSchema = z.object({
  page: z.coerce.number().min(1).default(1).catch(1),
  filter: z.string().optional().catch(undefined),
});

export const Route = createFileRoute('/__pathlessLayout/main')({
  component: MainPage,
  validateSearch: searchSchema,
});

function MainPage() {
  const search = useSearch({from: '/__pathlessLayout/main'});
  // search is fully typed: { page: number, filter?: string }

  return (
    <div>
      <h1>Main Page</h1>
      <p>Current page: {search.page}</p>
      {search.filter && <p>Filter: {search.filter}</p>}
    </div>
  );
}
```

**Using Search Parameters in Components:**

```typescript
import {useSearch} from '@tanstack/react-router';

const search = useSearch({from: '/__pathlessLayout/main'});
// search is fully typed based on the validateSearch schema
```

### TypeScript Integration

Type safety is ensured through module augmentation:

```typescript
// src/main.tsx
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
```

This enables:

- Type-safe route paths in `navigate()` calls
- Type-safe search parameters
- Type-safe route context
- Autocomplete for route names

## TanStack Query Setup

### Query Client Configuration

The QueryClient is created in `src/main.tsx` with sensible defaults:

```typescript
import {QueryClient, QueryClientProvider} from '@tanstack/react-query';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 2, // 2 minutes
      retry: 1,
    },
  },
});
```

**Configuration Details:**

- `staleTime: 2 minutes` - Data is considered fresh for 2 minutes, reducing unnecessary refetches
- `retry: 1` - Failed queries retry once before showing an error

**Provider Setup:**

```typescript
<QueryClientProvider client={queryClient}>
  <App />
</QueryClientProvider>
```

The QueryClientProvider wraps the application, making the query client available to all components.

### Query Keys Pattern

Query keys are centralized in `src/modules/api/query-keys.ts` using a structured, hierarchical pattern:

```typescript
export const queryKeys = {
  me: () => ['me'],
  households: {
    single: (id: string) => ['households', id],
  },
  accounts: {
    all: () => ['accounts'],
  },
  categories: {
    all: () => ['categories'],
  },
  transactions: {
    key: () => ['transactions'],
    all: (search: GetTransactionsQueryDTO) => ['transactions', search],
    allPagesKey: () => ['transactions-all-pages'],
    allPages: (search: Partial<GetTransactionsQueryDTO>) => ['transactions-all-pages', search],
    netWorthTrend: () => ['net-worth-trend'],
    spendingByAccounts: (search: GetAccountsSpendingQueryHouseholdDTO | GetAccountsSpendingQueryDTO) => [
      'spending-by-accounts',
      search,
    ],
    spendingTotal: (search: GetSpendingSummaryQueryHouseholdDTO) => ['spending-total', search],
    categoriesSpending: (search: GetSpendingSummaryQueryHouseholdDTO) => ['categories-spending', search],
  },
  users: {
    byHousehold: (householdId: string) => ['users', 'household', householdId],
  },
  categoryBudgets: {
    key: () => ['category-budgets'],
    all: (search: GetCategoryBudgetsQueryParams) => ['category-budgets', search],
  },
  privateTransactions: {
    key: () => ['private-transactions'],
    all: (search: GetPrivateTransactionsQueryDTO) => ['private-transactions', search],
  },
  scheduledTransactions: {
    key: () => ['scheduled-transactions'],
    all: (search: GetScheduledTransactionsQueryHouseholdDTO) => ['scheduled-transactions', search],
    single: (id: string) => ['scheduled-transactions', id],
  },
};
```

**Benefits of This Pattern:**

- Centralized key management
- Type-safe query keys
- Easy cache invalidation (can invalidate by prefix)
- Consistent key structure across the application

### Custom Hooks Pattern

Data fetching is encapsulated in custom hooks that use `useQuery`:

**Example: Simple Query Hook** (`src/modules/auth/hooks/use-get-me.ts`):

```typescript
import {me} from '@/modules/api/auth-api';
import {queryKeys} from '@/modules/api/query-keys';
import {useQuery} from '@tanstack/react-query';

export const useGetMe = () => {
  return useQuery({
    queryKey: [queryKeys.me],
    queryFn: me,
  });
};
```

**Example: Query with Dependencies** (`src/modules/scheduled-transactions/hooks/use-scheduled-transactions.ts`):

```typescript
export const useGetScheduledTransactions = (query: GetScheduledTransactionsQueryHouseholdDTO) => {
  const {data: me} = useGetMe();

  return useQuery({
    queryKey: queryKeys.scheduledTransactions.all(query),
    queryFn: () => {
      if (!me?.householdId) throw new Error('ID domaćinstva nije dostupan');
      return getScheduledTransactionsForHousehold(me.householdId, query);
    },
    enabled: !!me?.householdId,
  });
};
```

**Key Patterns:**

- Hooks are co-located with feature modules
- Query keys come from the centralized `queryKeys` object
- `enabled` option prevents queries from running until dependencies are met
- Type safety is maintained through TypeScript and contract types

### Mutations and Cache Invalidation

Mutations use `useMutation` and typically invalidate related queries on success:

**Example: Login Mutation** (`src/modules/auth/hooks/use-login-mutation.ts`):

```typescript
import {login} from '@/modules/api/auth-api';
import {queryKeys} from '@/modules/api/query-keys';
import {useMutation, useQueryClient} from '@tanstack/react-query';
import {useNavigate} from '@tanstack/react-router';
import {toast} from 'sonner';

export const useLoginMutation = () => {
  const navigate = useNavigate();
  const client = useQueryClient();

  return useMutation({
    mutationFn: login,
    onSuccess: async () => {
      await client.invalidateQueries({queryKey: [queryKeys.me]});
      await navigate({to: '/main', reloadDocument: true});
    },
    onError: async (error) => {
      // Error handling with analytics
      toast.error('Login failed');
    },
  });
};
```

**Example: Update Mutation with Multiple Invalidations**:

```typescript
export const useUpdateItem = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({id, dto}: {id: string; dto: UpdateItemDTO}) => updateItem(id, dto),
    onSuccess: () => {
      toast.success('Item updated successfully');
      // Invalidate multiple related queries
      void queryClient.invalidateQueries({queryKey: queryKeys.items.all()});
      void queryClient.invalidateQueries({queryKey: queryKeys.summary.key()});
    },
    onError: async (error) => {
      // Error handling
      toast.error('Update failed');
    },
  });
};
```

**Key Patterns:**

- Mutations invalidate related queries to keep UI in sync
- Multiple queries can be invalidated if they depend on the mutated data
- Router navigation is integrated into mutation success handlers
- Error handling includes user feedback (toasts) and analytics

### Router Integration

TanStack Query and Router work together seamlessly:

1. **Navigation in Mutations**: Mutations can navigate after success
2. **Query State in Routes**: Routes can use query hooks to determine context
3. **Search Parameters**: Query hooks can use validated search parameters from routes

**Example: Using Search Parameters with Queries**:

```typescript
import {useSearch} from '@tanstack/react-router';

const search = useSearch({from: '/__pathlessLayout/main'});

const {data} = useQuery({
  queryKey: queryKeys.items.all(search),
  queryFn: () => getItems(search),
});
```

## Development Tools

Both libraries include development tools that are conditionally rendered:

**React Query Devtools** (`src/app.tsx`):

```typescript
import {ReactQueryDevtools} from '@tanstack/react-query-devtools';

<ReactQueryDevtools initialIsOpen={false} />
```

**Router Devtools** (`src/routes/__root.tsx`):

```typescript
import {TanStackRouterDevtools} from '@tanstack/react-router-devtools';

<TanStackRouterDevtools position="bottom-left" />
```

These devtools provide:

- Query cache inspection
- Route tree visualization
- Performance monitoring
- Debugging capabilities

## Best Practices

### Router Best Practices

1. **Use File-Based Routing**: Let the plugin generate routes automatically
2. **Type Safety**: Always use `validateSearch` for query parameters
3. **Route Guards**: Use `beforeLoad` for authentication and authorization
4. **Layout Routes**: Use pathless routes (`__pathlessLayout`) for shared layouts
5. **Error Handling**: Provide a `defaultErrorComponent` for consistent error handling

### Query Best Practices

1. **Centralized Query Keys**: Keep all query keys in one file for easy management
2. **Custom Hooks**: Encapsulate queries in custom hooks for reusability
3. **Cache Invalidation**: Invalidate related queries after mutations
4. **Conditional Queries**: Use `enabled` to prevent unnecessary queries
5. **Error Handling**: Provide user feedback and log errors appropriately

### Integration Best Practices

1. **Context for Auth**: Use router context to share authentication state
2. **Navigate After Mutations**: Use router navigation in mutation success handlers
3. **Type Safety**: Leverage TypeScript for end-to-end type safety
4. **Search Params**: Use validated search parameters in query hooks

## Summary

This setup provides:

- **Type-safe routing** with file-based route definitions
- **Centralized state management** with TanStack Query
- **Seamless integration** between router and query libraries
- **Developer experience** with devtools and TypeScript support
- **Scalable patterns** for authentication, data fetching, and cache management

The combination of TanStack Router and Query creates a robust foundation for building type-safe, performant React applications with excellent developer experience.
